"use strict";

exports.__esModule = true;

exports["default"] = function (_ref) {
  var t = _ref.types;

  return {
    visitor: {
      UnaryExpression: function UnaryExpression(path) {
        var node = path.node;
        var parent = path.parent;

        if (node._ignoreSpecSymbols) return;

        if (path.parentPath.isBinaryExpression() && t.EQUALITY_BINARY_OPERATORS.indexOf(parent.operator) >= 0) {
          // optimise `typeof foo === "string"` since we can determine that they'll never need to handle symbols
          var opposite = path.getOpposite();
          if (opposite.isLiteral() && opposite.node.value !== "symbol" && opposite.node.value !== "object") {
            return;
          }
        }

        if (node.operator === "typeof") {
          var call = t.callExpression(this.addHelper("typeof"), [node.argument]);
          if (path.get("argument").isIdentifier()) {
            var undefLiteral = t.stringLiteral("undefined");
            var unary = t.unaryExpression("typeof", node.argument);
            unary._ignoreSpecSymbols = true;
            path.replaceWith(t.conditionalExpression(t.binaryExpression("===", unary, undefLiteral), undefLiteral, call));
          } else {
            path.replaceWith(call);
          }
        }
      },

      BinaryExpression: function BinaryExpression(path) {
        var node = path.node;

        if (node.operator === "instanceof") {
          path.replaceWith(t.callExpression(this.addHelper("instanceof"), [node.left, node.right]));
        }
      },

      "VariableDeclaration|FunctionDeclaration": function VariableDeclarationFunctionDeclaration(path) {
        if (path.node._generated) path.skip();
      }
    }
  };
};

module.exports = exports["default"];