"use strict";

var _interopRequireWildcard = require("babel-runtime/helpers/interop-require-wildcard")["default"];

exports.__esModule = true;

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var metadata = {
  optional: true
};

exports.metadata = metadata;
var visitor = {
  UnaryExpression: function UnaryExpression(path, file) {
    var node = path.node;
    var parent = path.parent;

    if (node._ignoreSpecSymbols) return;

    if (path.parentPath.isBinaryExpression() && t.EQUALITY_BINARY_OPERATORS.indexOf(parent.operator) >= 0) {
      // optimise `typeof foo === "string"` since we can determine that they'll never need to handle symbols
      var opposite = this.getOpposite();
      if (opposite.isLiteral() && opposite.node.value !== "symbol" && opposite.node.value !== "object") return;
    }

    if (node.operator === "typeof") {
      var call = t.callExpression(file.addHelper("typeof"), [node.argument]);
      if (this.get("argument").isIdentifier()) {
        var undefLiteral = t.stringLiteral("undefined");
        var unary = t.unaryExpression("typeof", node.argument);
        unary._ignoreSpecSymbols = true;
        return t.conditionalExpression(t.binaryExpression("===", unary, undefLiteral), undefLiteral, call);
      } else {
        return call;
      }
    }
  },

  BinaryExpression: function BinaryExpression(_ref, file) {
    var node = _ref.node;

    if (node.operator === "instanceof") {
      return t.callExpression(file.addHelper("instanceof"), [node.left, node.right]);
    }
  },

  "VariableDeclaration|FunctionDeclaration": function VariableDeclarationFunctionDeclaration(path) {
    if (path.node._generated) path.skip();
  }
};
exports.visitor = visitor;