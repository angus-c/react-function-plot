/* @flow */

"use strict";

var _interopRequireWildcard = require("babel-runtime/helpers/interop-require-wildcard")["default"];

exports.__esModule = true;

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

/*:: import type { NodePath } from "babel-traverse";*/

var awaitVisitor = {
  Function: function Function(path) {
    path.skip();
  },

  AwaitExpression: function AwaitExpression(_ref) {
    var node = _ref.node;

    node.type = "YieldExpression";

    if (node.all) {
      // await* foo; -> yield Promise.all(foo);
      node.all = false;
      node.argument = t.callExpression(t.memberExpression(t.identifier("Promise"), t.identifier("all")), [node.argument]);
    }
  }
};

var referenceVisitor = {
  ReferencedIdentifier: function ReferencedIdentifier(_ref2, state) {
    var node = _ref2.node;
    var scope = _ref2.scope;

    var name = state.id.name;
    if (node.name === name && scope.bindingIdentifierEquals(name, state.id)) {
      return state.ref = state.ref || scope.generateUidIdentifier(name);
    }
  }
};

exports["default"] = function (path /*: NodePath*/, callId /*: Object*/) {
  var node = path.node;

  node.async = false;
  node.generator = true;

  path.traverse(awaitVisitor);

  var call = t.callExpression(callId, [node]);

  var id = node.id;
  node.id = null;

  if (t.isFunctionDeclaration(node)) {
    var declar = t.variableDeclaration("let", [t.variableDeclarator(id, call)]);
    declar._blockHoist = true;
    return declar;
  } else {
    node.type = "FunctionExpression";

    if (id) {
      var state = { id: id, ref: null };

      path.traverse(referenceVisitor, state);

      if (state.ref) {
        path.scope.parent.push({ id: state.ref });
        return t.assignmentExpression("=", state.ref, call);
      }
    }

    return call;
  }
};

module.exports = exports["default"];